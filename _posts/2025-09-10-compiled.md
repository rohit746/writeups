---
layout: post
title: Compiled
date: 2025-09-10 01:39 +0530
categories: [ctf, tryhackme]
tags: [c, reverse-engineering]
description: "A Tale of a Flawed scanf"
---

Welcome to my write-up for a fun little
reverse engineering challenge from the
[Compiled](https://tryhackme.com/room/compiled) room on TryHackMe.
This challenge involves a simple Linux binary that asks for a password.
Our goal is to bypass this check by analyzing the program's logic. Let's dive in!

## Initial Reconnaissance

The first step with any unknown binary is to understand what it is and how it behaves.
I started by using the file command to identify its type and
then made it executable with `chmod`.

```bash
$ file Compiled.Compiled
Compiled.Compiled: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=..., not stripped

$ chmod +x Compiled.Compiled
```
{: .nolineno}

With the file ready, I ran it to see what it does.
As expected, it prompted for a password.
A simple guess like "test" resulted in a "Try again!" message.

```bash
$ ./Compiled.Compiled
Password: test
Try again!
```
{: .nolineno}

This confirms it's a standard password-checking program. Time to look under the hood.

I just used strings and got mocked that `"Strings is for Noob"`,
but we also got some other interesting printable strings like
`"Password"`, `"DoYouEven%sCTF"`,
`"__dso_handle"`, `"_init"`, `"Correct!"` and `"Try again!"`.
 Somewhere here lies the password, which will also be the flag.

![Strings](/assets/posts/compiled/compiled-2.png){: .shadow}

## Static Analysis with Ghidra
To understand the password-checking logic, we need to decompile the binary. My tool of choice for this is Ghidra.

After creating a new project in Ghidra, I imported the `Compiled.Compiled` binary and ran the default auto-analysis. Once the analysis was complete, I navigated to the Symbol Tree, expanded the Functions folder, and located the main function. The decompiled C code on the right-hand side gave me everything I needed.

Here is the C code that Ghidra produced for the `main` function:

![Ghidra Decompile](/assets/posts/compiled/compiled-1.png){: .shadow}

We see that the program prompts the user for a password and checks if it matches the exact string `"_init"` and is not equal to the string `"__dso_handle"`. If the input meets these conditions, it prints `"Correct!"`; otherwise, it prints `"Try again!"`.

## Deconstructing the Code
The logic resides in two key function calls: `__isoc99_scanf` and `strcmp`.

1. The `scanf` Call:
    ```c
     __isoc99_scanf("DoYouEven%sCTF", local_28);
    ```
    {: .nolineno}

    This line is the most interesting. The format string `"DoYouEven%sCTF"` suggests that the program expects the input to be structured with `DoYouEven` at the start, some string (`%s`) in the middle, and `CTF` at the end. The part captured by `%s` is stored in the `local_28` variable. (See the [scanf documentation](https://en.cppreference.com/w/c/io/fscanf) for more details on format strings.)

2. The `strcmp` Calls:
    The code then compares the string stored in `local_29` with two hardcoded values.

    - The first comparison, `strcmp(local_28,"__dso_handle")`, is a simple misdirection or a "troll" check. If the input matches, it prints `"Try again!"`.

    - The second comparison, `strcmp(local_28,"_init")`, is the real one. If the string in `local_28` is exactly `"_init"`, the program prints `"Correct!"`. The `strcmp` function returns `0` when the strings are identical.

## Discovering the Flaw
My first thought was to combine all the parts as suggested by the format string, but that approach failed. This led me to the core vulnerability.

The [`scanf` function returns the number of items it successfully read.](https://www.google.com/search?q=https://en.cppreference.com/w/c/io/fscanf%23Return_value) If it fails to match the full format string, it stops processing but **doesn't necessarily revert the changes it already made**.

When we provide an input that starts with DoYouEven followed by the target string from the second `strcmp` call:

1. `scanf` successfully matches the literal `DoYouEven`.

2. It then reads the target string into the `local_28` variable via `%s`.

3. Next, it tries to match the literal `CTF`, but it's not in the input stream. `scanf` stops and reports a failure.

4. **Crucially, the program never checks the return value of scanf to see if it succeeded!** It just plows ahead with the execution.

By the time the final `strcmp` function is called, the `local_28` variable already holds the correct value, and the check passes.

## Crafting the Solution
The solution is to provide an input that populates the `local_28` variable with the required string before the `scanf` function fails on its final check.

By combining the prefix from the `scanf` format string (`DoYouEven`) with the target string revealed in the second `strcmp` call, we can craft the input that fools the program.

Running the program with this crafted input results in the success message:

![Success](/assets/posts/compiled/compiled-3.png){: .shadow}

## Conclusion
This was a great little challenge that highlights a common programming mistake: failing to check the return values of functions. A robust program would have checked if `scanf` returned the expected value. Because this one didn't, we were able to bypass the check with a partially correct password.